Version: 2011-05-11
http://phpcr.github.com


The Java Content Repository specification is targeted at strongly typed
languages. PHP is weak typed. PHPCR is meant to implement JCR in the spirit
of PHP, not literally.

This page documents where PHPCR diverges from the JCR 283 API.

Short Summary of the important changes
**************************************

 * Get rid of Value and ValueFactory. They are only relevant with strong typing
 * Mark Node, Property and NamespaceRegistry with the Traversable interface for
    ease of use with foreach.
 * Drop the RangeIterator and Sub-Interfaces in favor of declaring return types
    implementing PHP iterators. The type specific iterators again are only
    relevant with strong typing.
 * Provide shortcut methods Node::getPropertyValue and Node::getPropertyValues
    to avoid instantiating property objects when not needed.
 * NOTE: All deprecated methods coming from JSR-170 have been completely left
    out

Basic conversion
****************

Most PHP coding standards require that interfaces have the Interface in their
name. We followed this, thus Node becomes NodeInterface and so on.

PHP does not allow method overloading (having the same method name with
different parameter numbers and/or types). PHP uses optional parameters with
default values instead. Wherever this was encountered in JCR, the methods are
mapped to one. For example, ItemVisitor::visit is only one method expecting
ItemInterface instead of two visit methods expecting Node and Property.
The implementing visitor will have to do a type-check.

 * In PHP you can not have a class method called "clone" because it is a
    reserved keyword. Workspace::clone is named Workspace::cloneFrom as it clones
    a node from a workspace into the current workspace.
 * For java.io.InputStream we use php streams (resources). For java.util.Calendar
    we use the DateTime class.

A note about the BOOLEAN value type. When converting String values to boolean,
JCR uses java.lang.Boolean.valueOf(String) which evaluates to true only for
the string "true" (case insensitive). The semantics in PHP is different:
everything different from null|0|false is true.
We chose to follow the PHP way to avoid confusion. When sharing data with a
Jackrabbit backend, you should be aware of the difference when converting
integer or string to boolean values.

For the DECIMAL type, we use string, as there is no equivalent to
java.math.BigDecimal in PHP. You can use bcmath to work with the large integer
strings. The encoding must always encode using the C locale because of
http://bugs.php.net/bug.php?id=16532


Iterators
*********

JCR defines many iterators with the single purpose of avoiding class-casting:
RangeIterator, NodeIterator, PropertyIterator, NodeTypeIterator, VersionIterator,
AccessControlPolicyIterator, RowIterator, EventIterator, EventListenerIterator
We loose nothing by dropping them.
EventJournal is a special case, containing "skipTo($date)". This iterator
is the only one that is kept.

(Probably JCR would better use a parametrized class for that anyway, available
since Java 1.5.)

Wherever the iterators are used, PHPCR requires iterators implementing
SeekableIterator and Countable. Together, those iterators have the same
expressivnes as the JCR RangeIterator.

Note: Plain PHP arrays would be even simpler than any interfaces, while still
allowing to use foreach. But they would have the major drawback that no lazy
loading is possible, all data has to be instantiated immediatly.
If an implementation does not want lazy loading, it can just create an
ArrayIterator from the array.


Additionally, we declared API elements as Traversable where it makes sense.
This allows to directly use the objects in a foreach statement.
The implementation either has to implement IteratorAggregate::getIterator to
return a suitable iterator, or be an iterator itselves.
PHP NOTE: When implementing our interfaces, you have to declare either
implements Iterator or IteratorAggregate explicitly in your class signature.
Do NOT put implements Traversable into the signature, it confuses PHP.

 * NodeInterface iterates over all children (like getNodes() without filters)
    The keys are the node names, the values the node objects.
 * PropertyInterface iterates over all values of that property. (Except for
    multivalue properties, there is exactly 1 value. The iterator keys have no
    significant meaning.
 * NamespaceRegistryInterface iterates over all namespaces. Keys are the
    prefixes, values are the uris.
 * Lock/LockManagerInterface iterates over all lock tokens
    (like getLockTokens()). The iterator keys have no significant meaning.
 * NodeType/NodeTypeManager iterates over all node types
    (like getAllNodeTypes()). The iterator keys have no significant meaning.
 * Observation/ObservationManagerInterface iterates over all registered event
    listeners (like getRegisteredEventListeners()). The iterator keys have no
    significant meaning.

 * Query/QueryResultInterface iterates over the rows (node is only a special case)

 * Query/RowInterface iterates over all row values, like getValues(). Keys are
    the column names, values the corresponding values.

 * Security/AccessControlEntryInterface iterates over all privileges, like
    getPrivileges(). The iterator keys have no significant meaning.
 * Security/AccessControlListInterface iterates over all entries, like
    getAccessControlEntries(). The iterator keys have no significant meaning.

For other interfaces there is no obvious default iterator, so we left them without.
Version/VersionHistoryInterface extends the NodeInterface. Even though iterating
over the versions seems natural, we did not want to change the behaviour for
this subclass of NodeInterface.


Value and ValueFactory
**********************

PHPCR got rid of both Value and ValueFactory. They only make sense in the
context of strong typing.

The PropertyInterface methods directly access the native property values.
We keep type conversions possible with the type-specific getters.

 * PropertyInterface::getValue returns the value in its default format
 * The type specific getters return a native value or an array of such values
    in case of multivalue properties.
 * PropertyInterface::setValue got an optional parameter for specifying the
    desired type if wanted. The method takes all functionality of
    ValueFactory::createValue

In all places where Value objects where used, this is changed to plain PHP
variables. This is true even for the Binary interface, as it adds no value over
plain streams. PropertyInterface::getBinaryStream returns a php resource which
is compatible with fpassthru and stream_get_contents.
If you need the data size, you can use the PropertyInterface::getLength method.
To copy a binary property without loading the stream to the backend, you can
assign the property to an other property.


Property
********

Instantiating property objects is often not needed. The Node interface got a
getPropertyValue($name, $type=false) that returns the native property value
(or array of values in case of multivalue property).
Additionally, there is a NodeInterface::getPropertiesValues($filter=null)
function with the same logic as NodeInterface::getProperties($filter) to get
an iterator with all property names => property value (resp value array for
multivalue properties).

For performance reason, implementations should delay instantiating the
PropertyInterface objects until they are actually needed.

We dropped the getValues and getLengths methods for *multivalue properties* in
favor of returning either a single value or an array of values in the same
method.

PropertyInterface::addValue() has been added to quickly append a value to
multi-value properties instead of requiring getValue()/append/setValue().

Note: We discussed even completely dropping the Property interface. But the
separation between Node and Property does make sense, plus allows for things
like the ItemVisitor.


Repository
**********

We changed getDescriptor() to return both single value descriptors and arrays.
isSingleValueDescriptor() has been removed.
getDescriptorValue() and getDescriptorValues() are removed too, see the Values
topic.

Note: The RepositoryFactory class uses the "Java Standard Edition Service
Provider mechanism". There is no equivalent in PHP. However, having a defined
way how to create the repository instance makes a lot of sense. It allows to
easily use different implementations. We kept the getRepository method and
added a getConfigurationKeys() method to allow for generic interactive setup.


Helpers
*******

The PropertyType (a final class implemented in the API, not an interface) does
basic type detection and conversion (in addition to the constants definition
according to the JCR specification). This has to be used for all conversions to
ensure compatibility between implementations. This is the only part of the
ValueFactory that we need to use in php.

PropertyType::valueFromType($type) returns the PHPCR numeric constant value of
the type for the given PHP type name as returned by gettype().

PropertyType::convertToType($value, $type) converts the value into the target
type.


Remark
******

You are free in your implementation to re-add the methods and classes we deemed
superfluous in PHP. Thanks to the weak typing, PHP won't complain when using
those methods even if they are not declared in the PHPCR interfaces. Of course,
your client code then will not be able to use other PHPCR implementations.


* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

Contributors:

* Karsten Dambekalns <karsten (at) typo3.org>
* David Buchmann <david (at) liip.ch>
* Lukas Kahwe Smith <lukas (at) liip.ch>
* Henri Bergius <henri.bergius (at) iki.fi>
* Jordi Boggiano <j.boggiano (at) seld.be>
* Christian Stocker <chregu (at) liip.ch>
